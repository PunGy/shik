; Numbers (floating point)
42
3.14
-17.5

; Strings (single quotes)
"hello world"
"path/to/file.txt"
"line with \"escaped\" quotes"
"line with 'quotes'"
:one-line-without-spaces-string
"any string can have {- 10 20} computed values"

; Lists
[]
[1 2 3]
[:a :b :c]
[[1 2] [3 4]]  ; nested lists
[f x] ; two elements, f and x
[(f x)] ; one element, result of apply x to f

; Objects
{}
{x 10 y 20} ; two items

let x 10

let st { :x 10 :y 20 }
obj.get :x st ;-- 10
obj.set :x 10 st ;-- 0

let f (fn [x y] + x y)

(10 -x)

let string.reverse (fn [str] '(
    let reversed ""
    let append (str.push reversed)
    str $> iterate-backward append
    reversed
))

let +' (fn [x y] + x y)

{* Block comment
 *
 * macro proposal:

let macrofn (macro [name] '(
  "let {+ fn "-" name} {+ 10 20}"
))
*}

file.read-safe :file.txt $> write :file.doc

;; Piping
file.read-safe :file.txt $>
    result.read-or false $>
    (fn [content] if content (string.upper content $> file.write :file.txt))
    ; (if-can (string.upper #> file.write :file.txt))


let ff (string.reverse #> string.upper)

file.read-safe :file.txt

;; if.can: reversed if with 
file.read-safe :file.txt $>
    result.read-or false $>
    if.can (string.upper #> file.write :file.txt)


let try-write (file.write :some.file "some content")

let x (if-can 10)

;; 10
print (x true)

;; void
print (x true)

;; Lowering application prescedence:
let result $ file.write :name.txt :content
let result (file.write :name.txt :content)
;; chaining:
let result $ file.write :name.txt :content $ :world?
let result ((file.write :name.txt :content) (:world))

{*
<expr> $ <expr>
is for:
(<expr>) (<expr>)
*}

;; print :success
if try-write (print :success) (print :error)

;; write wasn't called, always success
if 'try-write (print :success) (print :error)
